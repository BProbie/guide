

# 取模 mod

## 公式

```python
a % b = c
a = b * i + c # i∈Z
```



# 逆元 inv_n

## 公式

```python
inv_s = pow(s,-1,n)
```

## 应用

```python
c = (m * s) % n
m = (c / s) % n = (c * inv_s) % n
```



# 同余 ≡

## 公式

```python
a ≡ b (mod m) ⇔ (a - b) % m == 0
a = m * i + b # i∈Z
```



# 欧拉函数 Φ(n) | phi_n

## 公式

```python
# 若
n = p * q

# 则
phi_n = (p - 1) * (q - 1)
```



# pow中pow

## 公式

```python
# 若
a = pow(b,a1,n)
b = pow(c,a2,n)

# 则
a = pow(c,a1*a2,n)
```

## 应用

```python
# 已知
s = pow(y, k, p)
y = pow(g, x, p)
c = pow(g, k, p)

# 得到
s = pow(y, k, p) = pow(g, x*k, p) = pow(c, x, p)
```



# 分解大素数积 n

## 关系

```python
p = getPrime(512)
q = getPrime(512)
n = p * q
```

## 公式

### 工具库法

```python
from sympy import factorint

n = 114514
p, q = list(factorint(n).keys())

print(f"p{{{p}}} q{{{q}}}")
```

### 网站法

```python
https://tools.qsnctf.com/crypto/rsa_factordb
```



# p、q、n、phi_n、d、e、m、c、flag的基本运算关系

## 关系

```python
p < iroot(n, 2)[0] < q
```

## 公式

```python
n = p * q # 素数积
p = n // q # 素数p
q = n // p # 素数q
phi_n = (p - 1) * (q - 1) # 欧拉素数积

e = 65537 # 公钥
d = inverse(e, phi_n) # 私钥

c = pow(m, e, n) # 密文
m = pow(c, d, n) # 明文

m = bytes_to_long(flag) # 明文
flag = long_to_bytes(m).decode() # flag
```

## 例题

### 例题一

#### 题目

```python
from Crypto.Util.number import *
from gmpy2 import next_prime
from functools import reduce
from secret import flag

assert len(flag) == 38
assert flag[:7] == b'moectf{'
assert flag[-1:] == b'}'

def main():
    p = getPrime(512)
    q = int(reduce(lambda res, _: next_prime(res), range(114514), p))

    n = p * q
    e = 65537

    m = bytes_to_long(flag)

    c = pow(m, e, n)
	
    print(f'{n = }')
    print(f'{c = }')

if __name__ == '__main__':
    main()

"""
n = 96742777571959902478849172116992100058097986518388851527052638944778038830381328778848540098201307724752598903628039482354215330671373992156290837979842156381411957754907190292238010742130674404082688791216045656050228686469536688900043735264177699512562466087275808541376525564145453954694429605944189276397
c = 17445962474813629559693587749061112782648120738023354591681532173123918523200368390246892643206880043853188835375836941118739796280111891950421612990713883817902247767311707918305107969264361136058458670735307702064189010952773013588328843994478490621886896074511809007736368751211179727573924125553940385967
"""
```

#### 题解

```python
from Crypto.Util.number import *
from gmpy2 import next_prime, iroot

n = 96742777571959902478849172116992100058097986518388851527052638944778038830381328778848540098201307724752598903628039482354215330671373992156290837979842156381411957754907190292238010742130674404082688791216045656050228686469536688900043735264177699512562466087275808541376525564145453954694429605944189276397
c = 17445962474813629559693587749061112782648120738023354591681532173123918523200368390246892643206880043853188835375836941118739796280111891950421612990713883817902247767311707918305107969264361136058458670735307702064189010952773013588328843994478490621886896074511809007736368751211179727573924125553940385967
e = 65537

sqrt_n = iroot(n, 2)[0]
q = next_prime(sqrt_n)

while True:
    if n % q == 0:
        p = n // q
        phi_n = (p - 1) * (q - 1)
        d = inverse(e, phi_n)
        m = pow(c, d, n)
        flag = long_to_bytes(m).decode()
        if flag.startswith("moectf{") and flag.endswith("}"):
            print(flag) # moectf{vv0W_p_m1nu5_q_i5_r34l1y_sm4lI}
            break
    q = next_prime(q)
```



# 对模攻击

## 关系

```python
c1 ≡ m ** e1 (mod n)
c2 ≡ m ** e2 (mod n)

# 等价于
c1 = pow(m, e1, n)
c2 = pow(m, e2, n)
```

## 公式

```python
from Crypto.Util.number import *
from gmpy2 import *

g, s1, s2 = gmpy2.gcdext(e1, e2)
m = pow(c1, s1, n) * pow(c2, s2, n) % n
flag = long_to_bytes(gmpy2.iroot(m, g)[0]).decode()

print(flag)
```



# BSGS大步小步

## 公式

```python
import math
from math import gcd

def BSGS(a: int, b: int, m: int) -> int | None:
    m = abs(m)
    b = b % m
    a = a % m

    if m == 1:
        return 1
    if b == 1:
        return 0
    if a == 0:
        return 1 if b == 0 else None

    d = 0
    g = gcd(a, m)
    while g != 1:
        if b % g != 0:
            return None
        d += 1
        m = m // g
        b = b // g
        a = a // g
        g = gcd(a, m)
        if b == 1:
            return d

    t = math.ceil(math.sqrt(m))
    hash_map = dict()
    aj = 1
    for j in range(t):
        val = (b * aj) % m
        if val not in hash_map:
            hash_map[val] = j
        aj = (aj * a) % m

    at = pow(a, t, m)
    ati = 1
    for i in range(1, t + 1):
        ati = (ati * at) % m
        if ati in hash_map:
            x_prime = i * t - hash_map[ati]
            x = x_prime + d
            if pow(a, x, m * (10 ** d)) == b % (m * (10 ** d)):
                return x
    return None
```

## 应用

```python
(a ** x) ≡ b (mod m)
x = BSGS(a, b, m)
```

## 例题

### 例题一

#### 题目

```python
(13 ** flag) ≡ 114514 (mod 100000000000099) # 其中flag为最小整数
```

#### 题解

```python
flag = BSGS(13, 114514, 100000000000099)
print(f"moectf{{{flag}}}") # moectf{18272162371285}
```



# RSA

## 公式

### 加密

```python
from Crypto.Util.number import * # 这里是经典密码学的工具库，应该不会陌生
from secret import m # 这里用import导入明文

m = bytes_to_long(m) # 明文m，这里是字节流表达
p = getPrime(512) # 第512位质数，这里是bit位，即质数p∈(2**511,2**512)，这里存在多解，确解可通过抓包获取
q = getPrime(512) # 第512位质数，这里是bit位，即质数q∈(2**511,2**512)，这里存在多解，确解可通过抓包获取

e = 65537 # 公钥e，一般都是小整数
n = p * q # 模数n
c = pow(m, e, n) # 密文c，这里等价于c=m**e%n
```

### 解密

```python
from Crypto.Util.number import * # 一样的经典密码学的工具库

# 由加密过程和抓包得到的数据
p = getPrime(512) # 质数p，这里替换成确解
q = getPrime(512) # 质数q，这里替换成确解
e = 65537 # 公钥e
n = p * q # 模数n

phi_n = (p-1) * (q-1) # φ(n) = (p-1)*(q-1)
d = inverse(e, phi_n) # 私钥d直接调用逆模函数处理

m = pow(c, d, n) # 解密得到明文m的字节流表达
m = long_to_bytes(m) # 将字节流m转为字符串表示

flag = m.decode() # 解码明文成字符串byte -> str
```



# DES



# AES
