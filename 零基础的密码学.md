# 逆元

## 公式

```python
inv_s = pow(s,-1,n)
```

## 应用

```python
c = (m * s) % n
m = (c / s) % n = (c * inv_s) % n
```



# POW中POW

## 公式

```python
# 若
a = pow(b,a1,n)
b = pow(c,a2,n)

# 则
a = pow(c,a1*a2,n)
```

## 应用

```python
# 已知
s = pow(y, k, p)
y = pow(g, x, p)
c = pow(g, k, p)

# 得到
s = pow(y, k, p) = pow(g, x*k, p) = pow(c, x, p)
```



# RSA

## 公式

### 加密

```python
from Crypto.Util.number import * # 这里是经典密码学的工具库，应该不会陌生
from secret import m # 这里用import导入明文

m = bytes_to_long(m) # 明文m，这里是字节流表达
p = getPrime(512) # 第512位质数，这里是bit位，即质数p∈(2**511,2**512)，这里存在多解，确解可通过抓包获取
q = getPrime(512) # 第512位质数，这里是bit位，即质数q∈(2**511,2**512)，这里存在多解，确解可通过抓包获取

e = 65537 # 公钥e，一般都是小整数
n = p*q # 模数n
c = pow(m, e, n) # 密文c，这里等价于c=m**e%n
```

### 解密

```python
from Crypto.Util.number import * # 一样的经典密码学的工具库

# 由加密过程和抓包得到的数据
p = getPrime(512) # 质数p，这里替换成确解
q = getPrime(512) # 质数q，这里替换成确解
e = 65537 # 公钥e
n = p*q # 模数n

phi_n = (p-1)*(q-1) # φ(n) = (p-1)*(q-1)
d = inverse(e, phi_n) # 私钥d直接调用逆模函数处理

m = pow(c, d, n) # 解密得到明文m的字节流表达
m = long_to_bytes(m_long) # 将字节流m转为字符串表示
```

